{
  "hash": "3af131ac9920d9f6ede16c31326f7705",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Multivariate Regression and Model Selection with ![](../img/Rlogo.png){width=60px}\"\nsubtitle: <span style=\"color:#2C3E50\">11.118/11.218 Applied Data Science for Cities</span>\ndate: \"Last Updated 2025-09-02\"\nformat: html\neditor: visual\nexecute: \n  warning: false\n---\n\n\n# Introduction\n\nThis week begins our journey into machine learning. Ken Steif’s [book chapter](https://urbanspatial.github.io/PublicPolicyAnalytics/intro-to-geospatial-machine-learning-part-1.html) walks through an example using Boston housing data, showing how to build, apply, and evaluate a predictive model for home prices. We will build our study on this example, and continue to explore more models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(caret)\n```\n:::\n\n\n# Data Processing\n\n## Get to know the variables\n\nWe’ll be working with the CSV dataset containing sale prices and housing characteristics for homes sold in Boston between August 2015 and August 2016. The data used in this tutorial is a subset of a larger dataset assembled from [here](https://data.boston.gov/dataset/property-assessment). You can explore the full [data dictionary here](https://data.boston.gov/dataset/property-assessment/resource/dbdc1bd8-60af-4913-a788-5f91cb68541b).\n\nRead in the dataset using `read_csv()` and take an initial look using functions like `glimpse()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboston <- read_csv(\"../data/boston_house_price_collapse.csv\")\n#head(boston)\n```\n:::\n\n\nA few notes:\n\n-   The `SalePrice` variable is the target we want to predict.\n-   Other columns describe building characteristics such as square footage, number of floors, and number of bedrooms.\n-   Some variables are numeric (`dbl`), while others are categorical (`chr` or `fct`).\n\n**Question:** Based on your first observation, which variables do you think might be strong predictors of house price? Which ones seem less useful?\n\n## **EDA and data processing**\n\nBefore feeding any data into a model, we need to understand and clean it. Every dataset is different, but there are some key steps you should always consider:\n\n1.  Understand data structure: `str()`, `glimpse()` are useful to get to know the details of variables we are dealing with. Numeric and categorical variables require different treatment in a model later on so this is something to keep in mind. We will also see in our case, `parcel_no` is just an identifier and is not useful for predicting price.\n\n2.  Handle missing values. `is.na()`, `sum(is.na(...))`, `colSums(is.na(...))` can help identify which variables have missing values and how many. But how will deal with them (drop, fill, or flag) will depend on variable contexts and further inspection.\n\n3.  Look at distributions. This is an important step before fitting a regression model because it helps guide feature selection and transformation. We will take a closer look at how these relationships show up in different types of variables:\n\n    ### Continuous variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboston |> \n  select(SalePrice, PricePerSq, LivingArea, GROSS_AREA, NUM_FLOORS, R_BDRMS) |> \n  pairs()\n```\n\n::: {.cell-output-display}\n![](lab8_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe `pairs()` function creates a pairwise scatter plot matrix, which lets you visually examine the relationships between multiple variables at once. In the graph, we usually look for the following:\n\n1.  **Top row** (`SalePrice` as Y-axis): These show how each predictor relates to the outcome. If you see an upward trend (a roughly linear increase with `SalePrice`), that predictor is likely to be a strong predictor of price.\n\n2.  **Relationships between predictors:** Look for predictors that are highly correlated with each other (a sign of multicollinearity). For instance, `LivingArea` and `GrossArea` may appear nearly linear in their scatterplot. If you calculate the Pearson correlation, it's about 0.94. This means they contain overlapping information.\n\n    -   Depending on the modeling method (e.g., linear regression vs. tree-based methods), multicollinearity may or may not be a serious concern, but it’s always worth noting.\n\n3.  **Pattens, outliers and clusters.** These visual cues in pairwise plots help you decide whether a linear model is appropriate, and whether certain data points might influence your results. For example:\n\n    -   The variable `PricePerSq` may look odd with a bunch of y values lining up at x=0. `PricePerSq` here is a derived variable, calculated as `SalePrice / LivingArea`. Since it's directly related to the outcome, it should not be used as a predictor of `SalePrice`.\n\n    -   You’ll also notice outliers especially for luxury homes that have extremely high sale prices. This should match what you would see in the histogram of `SalePrice`. Most homes are priced under \\$1 million, but a small number of high-end homes stretch the distribution far to the right.\n\n### Categorical variables\n\nYou can make scatterplots with categorical variables too (i.e., by including them in a `pairs()` plot), but the results often look strange or uninformative, because points just line up vertically at two or three x-values. A better approach is to compare the average outcome across the categories. For example, you can group the data by a variable like `Style` and compute the mean `Saleprice` for each category:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboston |> \n  select(SalePrice, Style, OWN_OCC, R_BLDG_STY, R_ROOF_TYP) |> \n  filter(SalePrice <= 1000000) |> \n  pivot_longer(-SalePrice, names_to = \"Variable\", values_to = \"Value\") |>  \n  group_by(Variable, Value) |> \n  summarise(mean_price = mean(SalePrice, na.rm = TRUE)) |> \n  \n  ggplot() +\n    geom_col(aes(x = Value, y = mean_price),position = \"dodge\") +\n    facet_wrap(~ Variable, scales = \"free_x\") +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    labs(y = \"Mean Sale Price\", x = \"Category\", title = \"Mean SalePrice by Categorical Variables\")\n```\n\n::: {.cell-output-display}\n![](lab8_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nWhen examining categorical variables, we’re not looking for a linear trend, because the categories don’t have a natural order or numeric spacing. Instead, we focus on two main things:\n\n1.  **Rare or problematic categories**. Just like with missing values in numeric variables, rare categories can cause problems in modeling. For example, if we look at the `Style` variable, we might see a category labeled \"Unknown\" and it only appears twice in the dataset. Such categories don’t offer enough data to reliably estimate their effect, may introduce noise, and might need to be removed or combined.\n\n2.  **Differences between groups**. We want to know if the categories differ meaningfully in the outcome variable. If all the categories have similar average sale prices, it means the variable doesn’t explain much of the variation in price and is likely a weak predictor. In our case, `OWN_OCC` seems to have little impact on sale price.\n\n3.  **The meaning of the variables.** For example, `R_BLDG_STY` is just an abbreviation of `Style`. `LU` (land use) is zoning requirement (what should be built), not the actual buildings (what is built), so it isn’t useful for predicting housing prices.\n\n# **Build a basic linear model**\n\nWe have found a few flags. Let’s first remove a few variables that look irrelevant, and try a simple linear model to see how things look.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodeldata <- boston |> \n  select(-c(Parcel_No, PricePerSq, LU, \n            R_BLDG_STY, OWN_OCC, Latitude, Longitude))  \n\nlm_model <- lm(data = modeldata, SalePrice ~ .)\nsummary(lm_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = SalePrice ~ ., data = modeldata)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1597341  -165363     3626   151392  6593495 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         416103.41  195242.46   2.131 0.033238 *  \nLivingArea             561.72      46.14  12.174  < 2e-16 ***\nStyleColonial      -194221.66   50280.41  -3.863 0.000117 ***\nStyleConventional  -121277.27   57828.47  -2.097 0.036149 *  \nStyleDecker         -70758.02   81530.23  -0.868 0.385606    \nStyleOther           10486.57   54318.92   0.193 0.846942    \nStyleRow_End        146252.92   76767.07   1.905 0.056957 .  \nStyleRow_Middle     354795.62   78247.22   4.534 6.25e-06 ***\nStyleSemi_Det       -83145.77   73247.74  -1.135 0.256507    \nStyleTwo_Fam_Stack   15702.15   62947.42   0.249 0.803049    \nStyleUnknown       -505575.68  283022.04  -1.786 0.074251 .  \nStyleVictorian     -401648.53  114466.53  -3.509 0.000464 ***\nGROSS_AREA            -185.26      28.23  -6.563 7.33e-11 ***\nNUM_FLOORS          183703.65   38345.21   4.791 1.83e-06 ***\nR_BDRMS             -34361.82   11075.64  -3.102 0.001956 ** \nR_FULL_BTH          203440.33   21605.79   9.416  < 2e-16 ***\nR_HALF_BTH           83872.06   21654.04   3.873 0.000112 ***\nR_KITCH            -267530.76   31813.53  -8.409  < 2e-16 ***\nR_FPLACE            177086.83   16040.50  11.040  < 2e-16 ***\nR_ROOF_TYPG         170875.03   42916.83   3.982 7.18e-05 ***\nR_ROOF_TYPH         157849.24   50482.23   3.127 0.001802 ** \nR_ROOF_TYPL         165150.68   75314.64   2.193 0.028479 *  \nR_ROOF_TYPM         335336.24   54649.85   6.136 1.09e-09 ***\nR_ROOF_TYPS         311410.36  203843.55   1.528 0.126806    \nR_ROOF_TYPU         309536.80  187098.98   1.654 0.098261 .  \nR_TOTAL_RM          -19668.96    8203.00  -2.398 0.016620 *  \nYR_BUILT              -296.40      98.58  -3.007 0.002687 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 396200 on 1458 degrees of freedom\nMultiple R-squared:  0.5782,\tAdjusted R-squared:  0.5706 \nF-statistic: 76.86 on 26 and 1458 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n## Model Interpretation\n\n1.  Coefficients: **Effect Size**\n\nThe `Estimate` tell us how each predictor is associated with `SalePrice`, assuming all other variables are held constant. The sign of the values (+ or -) tell you the direction of the relationship.\n\n> i.e. if `LivingArea` go up by 1 square feet, the house price tends to **increase** by about **\\$561.47**, keeping all other factors the same.\n\nThe `Standard Error` is about how certain we are about the estimate, smaller values mean more confidence.\n\n> i.e. if you ran your regression many times, the estimate (e.g., \\$561.47) for `LivingArea` would vary, on average, by \\$46.15 above or below that value.\n\n-   Then we might see a few issues: `GROSS_AREA` is *negatively associated* with housing price, so is `R_BDRM`, which doesn’t make intuitive sense. This relates back to the multicollinearity issue we've spotted. When two predictors relate to each other, the model struggles to disentangle their individual effects.\n\nFor categorical variables, `estimate` shows how much the outcome differs from one *reference category*. For example, `Style` includes 11 types of housing style, R will pick one (like \"Cape\") as the baseline. If the coefficient for `\"Colonial\"` is -190,000, it means homes with the `\"Colonial\"` style are predicted to cost \\$190,000 less than `\"Cape\"` style homes, on average.\n\n2.  Coefficients: **Significance**\n\nThe `t-statistics` and its mirror image, the `p-value`, measures the extent to which a coefficient is \"statistically significant\", in other words, whether the relationship we see between that predictor and the outcome is likely real, or could have happened just by random chance.\n\nThe higher that t-statistics (and the lower the p-value), the more significant the predictor. Since parsimony is a valuable model feature, it is useful to have a tool like this to guide choice of variables to include as predictors.\n\n3.  **Model performance**\n\nModel performance means how well our regression model fits the data and how useful it is for making predictions. We have several key metrics to evaluate this:\n\nThe **coefficient of determination (R²)** tells us the proportion of variance in the outcome that is explained by the predictors, *ranging from 0 (no explanatory power) to 1 (perfect fit).*\n\nThe **residual standard error (RSE)** measures the average size of the prediction errors of the outcome. *Lower values indicate a better model fit.*\n\nThe **model p-value**, derived from an F-test, tells us whether the model as a whole is statistically significant, i.e. whether it does an overall better job than a model with no predictors.\n\nWith that, we can see our linear model explains \\~57% of the variation in sale prices. On average, data points are \\$396,300 away from the values on the regression line. The model is decent, but not great.\n\n# **Moving to Machine Learning**\n\nTraditionally, the primary use of regression models was to **understand and explain** the relationship between variables. The main focus was on the estimated parameters, which tell us how each predictor is associated with the outcome.\n\nWith the advent of big data, we started to care more about how well models can **predict** - so as to forecast outcomes for new data. Alongside regression, many machine learning methods are now also used to improve predictive accuracy.\n\n-   **Traditional statistical methods** might ask:\\\n    *\"How does LivingArea affect SalePrice? Is the effect statistically significant?\"*\n\n-   **Machine learning** asks:\\\n    *\"Can we accurately predict SalePrice given10 features?\"*\n\nThe three model performance metrics we looked at earlier (R-square, RSE, p-value) show how well our model **fits** the existing data. They’re based on residuals, which measure how far the regression line is from the actual data points. However, these metrics don’t tell us how well the model will **predict** on new, unseen data.\n\nTo evaluate the model’s predictive power, we need to:\n\n1.  **Apply the model to a new dataset.** In machine learning, we usually split the data into a **training set** and **a test set** for this purpose. We train the model on one portion of the data, and test it on the rest to see how well it generalizes.\n\n2.  **Compare the predicted values with the actual values in the test set.** The primary metric we use is **RMSE** (Root Mean Squared Error). RMSE measures the average difference between the predicted values and the actual values. The lower the RMSE, the better the model’s predictive accuracy.\n\n## **Machine Learning Workflow**\n\nI will go through a full modeling workflow using the `caret` package. We’ll probably repeat this workflow several times in upcoming sessions. The code won’t change much because `caret` lets you build many models (`lm`, `glmnet`, `rf`, `svm`, `xgbTree`, etc.) using a consistent syntax.\n\n**Step 1:** Data Preprocessing\n\nWhat you would do in this step depends on your specific data. For our case, as we’ve observed during the EDA earlier, we can consider:\n\n-   Remove irrelevant columns, such as IDs.\n-   Drop or combine categories with very few cases.\n-   Handle outliers, especially for skewed variables like SalePrice.\n    -   Option 1: Drop extremely high values (e.g., over \\$5M).\n    -   Option 2: Log-transform SalePrice, but that changes interpretation. For simplicity, we’ll just drop a few extreme outliers here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodeldata <- boston |> \n  select(-c(Parcel_No, PricePerSq, LU, \n            R_BLDG_STY, OWN_OCC, Latitude, Longitude))  |> \n  filter(Style != \"Unknown\") |> \n  filter(SalePrice < 5000000)\n```\n:::\n\n\n**Step 2:** Split data into training and testing sets\n\nThis involves first applying `createDataPartition` to generate row indices for the training set, then using those row indices to isolate the two subsets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set a fix \"random seed\" to make the split reproducible\nset.seed(42)  \n\n# Generate row indices for the training set\ntrain_index <- createDataPartition(\n  y = modeldata$SalePrice, # stratify based on the SalePrice variable\n  p = 0.7,                 # we want 70% of the data in the training set.\n  list = FALSE             # makes sure the output is a vector, not a list, so it's easier to use for indexing.\n)\n\n# Isolate the two subsets\ntrain_data <- modeldata[ train_index,]\ntest_data  <- modeldata[-train_index,]\n```\n:::\n\n\n**Step 3:** Build the model\n\nIn the following code, you can swap out the model by simply changing the argument for `method=` , such as linear regression (`\"lm\"`), random forest (`\"rf\"`), elastic net (`\"glmnet\"`), XGBoost (`\"xgbTree\"`), etc.\n\nAnother important point in this model is that we’ve set up cross-validation using `trainControl()`. Cross-validation means we're splitting the `train_data` into smaller parts **during training** to better evaluate model performance. Specifically, with 5-fold cross-validation (`number = 5`):\n\n-   Each time, one part of the data is set aside as a **validation set**, and the model is trained on the remaining parts.\n-   Then, the model is tested on that validation set.\n-   This process is repeated 5 times so that every fold (or subset) gets a turn as the validation set.\n\nWhy do we do this? Because it helps us avoid results that are just due to random chance from a single split. Finally, the validation results from all 5 folds are averaged, which gives us a more stable and reliable estimate of model performance before we even touch the test set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_model <- train(\n  SalePrice ~ .,                \n  data = train_data,\n  method = \"lm\",          # this is where you change model type\n  trControl = trainControl(method = \"cv\", number = 5)\n)\n```\n:::\n\n\n**Step 4:** Evaluate Model Accuracy Using RMSE\n\nNow we evaluate how well our model performs on unseen data, that’s what the test set is for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use predict() to generate predicted sale prices for the test set.\npred <- predict(lm_model, newdata = test_data) \n\n# compare those predictions to the actual sale prices using RMSE\nlm_result <- RMSE(pred, test_data$SalePrice)\n\nlm_result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 270157.2\n```\n\n\n:::\n:::\n\n\n`RMSE` is calculated by compare the predicted and actual values in the test data, square it, find the mean, then take the square root, you have do it by hand like the following code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mean((test_data$SalePrice - pred)^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 270157.2\n```\n\n\n:::\n:::\n\n\n## **Regularization: Controlling Model Complexity**\n\nIt might seem like a good idea to include as many variables as possible in our linear model, but that’s not always the best approach. When we include too many predictors, the model can start to *overfit*, meaning it fits the training data too closely and ends up capturing random noise rather than meaningful patterns.\n\nRegularization, in its broad sense, is a way to keep models simpler and more generalizable. For linear models, regularization helps the model to \"selectively use\" only the most important predictors.\n\nThere are two common types of *linear model* regularization: **Ridge regression** shrinks the coefficients of less important variables. **Lasso regression** shrinks some coefficients all the way to zero, effectively dropping those variables from the model.\n\nI'm repeating and putting the four steps together in the following code. The only difference is in the model-building step. Different models require their own set of tuning parameters, which we’ll explore more next week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodeldata <- boston |> \n  select(-c(Parcel_No, PricePerSq, LU, \n            R_BLDG_STY, OWN_OCC, Latitude, Longitude))  |> \n  filter(Style != \"Unknown\")|> \n  filter(SalePrice < 5000000)\n\nset.seed(42)  # for reproducibility\n\ntrain_index <- createDataPartition(\n  y = modeldata$SalePrice,\n  p = 0.7,\n  list = FALSE\n)\n\ntrain_data <- modeldata[ train_index,]\ntest_data  <- modeldata[-train_index,]\n\nlasso_model <- train(\n  SalePrice ~ ., \n  data = train_data,\n  trControl = trainControl(method = \"cv\", number = 5),\n  method = \"glmnet\",\n  tuneLength = 10,\n  preProcess = c(\"center\", \"scale\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npred <- predict(lasso_model, newdata = test_data) \nlasso_result <- RMSE(pred, test_data$SalePrice)\nlasso_result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 268975.5\n```\n\n\n:::\n:::\n\n\n## Non-linear model\n\nSo far we have been working with linear models, But sometimes, the data just doesn’t fit a straight line (or a flat plane, if we’re in a space with many variables). Real-world relationships can be nonlinear, irregular, or involve interactions between variables that a linear model can’t easily capture.\n\nWe will introduce Random Forest model next time, but it is one of the machine learning models that do not assume a straight-line relationship between predictors and the outcome (non-linear model), and do not rely on a fixed number of parameters (non-parametric model). The model learns the structure from the data itself.\n\nHere is how we change the workflow to building a random forest model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nrf_model <- train(\n  SalePrice ~ .,        \n  data = train_data,\n  method = \"rf\",        \n  trControl = trainControl(\"cv\", number = 5),\n  tuneLength = 5\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npred <- predict(rf_model, newdata = test_data) \nrf_result <- RMSE(pred, test_data$SalePrice)\nrf_result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 243903.8\n```\n\n\n:::\n:::\n\n\n# Model Summary\n\nHere’s a summary of our model results using the same dataset and 5-fold cross-validation. We tried a simple linear model, a Lasso model, and a Random Forest model. Their RMSE values differ, with the more flexible, nonlinear Random Forest achieving the lowest RMSE.\n\nFlexible models can capture complex patterns better, but better performance isn’t guaranteed. It depends on the data’s shape and distribution. In machine learning, we usually test multiple models to find the one with the best prediction accuracy, which is at the core of this field.\n\n| Model Type               | RMSE                                                         |\n|----------------------------|--------------------------------------------|\n| Simple linear regression | 270,157.2    |\n| Lasso regression         | 268,975.5 |\n| Random Forest            | 243,903.8    |\n\nAs you’ve likely noticed, when we used different models, details like `tuneLength`, `preprocess` changed. The `caret` package supports over 230 machine learning algorithms. Each model comes with its own set of hyperparameters that need to be tuned. We’ll explore those in more detail next time.\n\n# Lab Report\n\nThe Ames Housing dataset was compiled by Dean De Cock for use in data science education. It's also a popular dataset in the [Kaggle](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview) community. You can find a wealth of prediction projects and explore the various approaches people have taken with this dataset.\n\nUsing this data, please fit three different models and run them to calculate their RMSE values. This will require some basic data preprocessing and proper model setup to ensure each model works correctly. Include a summary table that compares the RMSE results from the three models.\n\nIn your report, please present your workflow and reasoning, including how you prepared the data, selected models and variable, and addressed any data issues you might have encountered.\n\nPlease include all your work in a Quarto document and submit your Rendered HTML file to Canvas by the end of day, Tuesday, Sep 23.\n",
    "supporting": [
      "lab8_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}