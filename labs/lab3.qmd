---
title: "Data Visualization with ![](../img/Rlogo.png){width=60px}"
subtitle: <span style="color:#2C3E50">11.118/11.218 Applied Data Science for Cities</span>
date: "Last Updated `r Sys.Date()`"
format: html
editor: visual
execute: 
  warning: false
---

# Airbnb Data

[Inside Airbnb](http://insideairbnb.com/) provides a freely available dataset that lets you explore Airbnb listings and related metrics for cities worldwide.

On [this data downloading page](http://insideairbnb.com/get-the-data/), search for the City of Chicago. You’ll see a list of files with descriptions. Take a moment to review them. The first file, `listings.csv.gz` is "Detailed Listings data". It contains raw information scraped directly from Airbnb’s website. Our task today is to extract meaningful insights from this dataset.

In the lecture, we briefly explored this data and you noted down some questions you want to investigate. Now, we’ll clean the data, create visualizations, and work toward answering those questions.

```{r}
#| message: false
library(tidyverse)
library(plotly)
library(gt)
```

The .gz file is only a compressed file format. `read_csv()` automatically detects `.gz` and decompresses it on the fly.

```{verbatim}
airbnb <- read_csv("listings.csv.gz")
```

```{r}
#| message: false
#| include: false
airbnb <- read_csv("../data/listings.csv.gz")
#data2 <- read_csv("data/listings.csv")
```

Take a look through the 79 variables included in the dataset along with the [data dictionary](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit?usp=sharing). Try to understand what each one means and what it tells you about a property.

Start a new Quarto file and begin by listing out three questions you’re curious about. These can be things like:

-   How does the price of an Airbnb listing vary by type of housing?
-   Are there patterns in availability across neighborhoods?
-   How do different types of hosts set their minimum stay requirements?

I'll walk through a few examples to introduce some new packages and demonstrate how to work with different types of variables

# Working with text data using `stringr`

We can come across with unstructured text input in our work. Examples include extracting all email addresses from text, counting how often a keyword appears, or cleaning up messy formatting (e.g., removing symbols like \$ or \*). These tasks involve string (i.e. characters) manipulation, and in R, we commonly use `stringr`, which is also part of `tidyverse`.

Typing `str_` will trigger autocomplete, allowing you to see all available functions in this package. For example:

`str_c()` combine multiple strings.

```{r}
# This combine street, city, state into full address
str_c("77 ", "Massachusetts ", "Ave")
```

`str_split()` splits strings by a separator, which could be a space, a comma, etc.

```{r}
# This separates first and last name into two parts
str_split(string = "Hadley Wickham", pattern = " ")
```

`str_pad()` add padding characters to strings (either left or right)

```{r}
# This adds leading zeros to ZIP codes
str_pad("2140", pad = "0", side = "left", width = 5)
```

Here we are going to use string modification to clean the `price` column in `airbnb`. If you look at the data (e.g., with `glimpse(airbnb)`), you’ll see that the prices are stored as **characters, not numbers**. Converting functions like `as.numeric()` won’t work directly here because the prices include a dollar sign (\$) and commas, like this: "\$1,200,000". We first need to modify the strings to remove the dollar signs and commas, before we can convert them to numeric prices and calculate them.

In a more general sense, we will replace those symbols with an empty string (""), effectively removing them.

`str_replace` replaces by pattern.

```{r}
str_replace(string = "$1,200", pattern = ",", replacement = "") 
```

Or if use str_replace_all, it can detect and remove multiple symbols simutaneously, by wrapping them in brackets

```{r}
str_replace_all(string = "$1,200.00", pattern =  "[$,]", replacement = "")
```

Here we make a small dataset that only include property id, room types and price:

```{r}
df_price <- airbnb |> 
  select(id, room_type, price) |> 
  mutate(price = str_replace_all(string = price, 
                                 pattern = "[$,]", 
                                 replacement = "")) |> 
  mutate(price = as.numeric(price))
```

Then we can create a bar chart that displays the median price for each type of property.

```{r}
df_price |> 
  filter(price < 10000) |> 
  group_by(room_type) |> 
  summarise(median_price = median(price, na.rm = TRUE)) |> 
  ggplot() + 
    geom_col(aes(x = room_type, y = median_price), 
             fill = "#62A0CA", width = 0.5) + 
  theme_bw()+
  labs(x = "Room Type", y = "Median Price")
```

# Interactive graphs with `plotly`

`plotly` is much larger than just the R universe, with implementations in Python, Julia, Javascript, and others. However, its interface with `ggplot2` is practically easy to use! All we need to do is to use the `ggplotly()` function to convert a ggplot object into an interactive plotly plot.

```{r}
g <- df_price |> 
  filter(price < 10000) |> 
  group_by(room_type) |> 
  summarise(median_price = median(price, na.rm = TRUE)) |> 
  ggplot() + 
    geom_col(aes(x = room_type, y = median_price), 
             fill = "#62A0CA", width = 0.5) + 
  theme_bw()+
  labs(x = "Room Type", y = "Median Price")


ggplotly(g)
```

# Working with dates using `lubridate`

Sometimes, you'll need to work with dates in your analysis. Date can come with different format, like "Sep 21, 2025", "09/21/2025", or "2025-09-21", etc. One noteworthy `lubridate` function is to standardize it, and you can even extract the componets for

`ymd` (and its siblings `mdy` , `dmy`, and `ymd_hms`...). It's a convenient function that converts strings into proper date objects. To use it, identify the order in which year, month, and day appear in your dates, then arrange "y", "m", and "d" in the same order.

```{r}
df_age <- airbnb |> 
  select(id, host_since) |> 
  mutate(host_since = ymd(host_since)) |> 
  mutate(host_since_year = year(host_since)) 
```

The above code shows that we can create another smaller dataset that includes the listing ID and the date the property was first listed (host_since). We then convert the character format of the date into a proper date using `ymd()`, and finally extract the year from it for further analysis. So that you can see how many properties started in each year.

We can visualize this result using a [`plotly` treemap](https://plotly.com/r/treemaps/). A treemap shows proportions using nested rectangles, and it's great for quickly comparing categories.

```{r}
df_age |> 
  count(host_since_year) |> 
  plot_ly(
    type = "treemap",
    labels = ~host_since_year,
    parents = "",  # No hierarchy, just one level
    values = ~n
  )
```

Plotly uses its own plotting grammar, but it shares a lot of similarities with ggplot2. For example, you still map variables to aesthetics like `labels`, `values`, and hierarchy levels, and the structure of the plot is layered.

I’d perfer to use `ggplotly` to convert almost any ggplot graphs to save me from having to remember a new set of functions. But for your interest in digging deeper into `plotly`, check out [`plotly` R graph library](https://plotly.com/r/) and its [`ggplot2` integration examples](https://plotly.com/ggplot2/).

# Create Nicer Tables Using `gt`

Now suppose you're planning a trip to Chicago and want to stay in the "Logan Square" neighborhood. I decide to dig into the Airbnb dataset to find hosts who have both good ratings and are actively getting reviews.

In the following code, I start by consulting the data dictionary to identify relevant variables. Then I calculate how many reviews each host has received in the last 30 days, as well as their average ratings.

```{r}
df_review <- airbnb |> 
  select(id, host_id, host_name, neighbourhood_cleansed,
         number_of_reviews_l30d, review_scores_rating) 

top_reviewed_hosts <- df_review |> 
  filter(neighbourhood_cleansed == "Logan Square") |> 
  group_by(host_id, host_name, review_scores_rating) |> 
  summarise(n = sum(number_of_reviews_l30d),.groups = "drop") |> 
  arrange(desc(n)) |> 
  head(10)


top_reviewed_hosts
```

`gt` can create more presentable, and customizable tables. For instance, we can add a few more lines to enhance this table by adding colorization based on these values.

```{r}
top_reviewed_hosts <- 
  top_reviewed_hosts |> 
  rename(
    `Host ID` = host_id,
    `Host Name` = host_name,
    `# Reviews` = n,
    `Rating` = review_scores_rating
  ) 

top_reviewed_hosts|> 
  gt() |> 
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#F0F0F0")  # Optional: light gray background
    ),
    locations = cells_column_labels(everything()))
```

```{r}
top_reviewed_hosts|> 
  gt() |> 
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#F0F0F0")  # Optional: light gray background
    ),
    locations = cells_column_labels(everything())) |> 
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#F0F0F0")  # Optional: light gray background
    ),
    locations = cells_column_labels(everything())) |>
  tab_header(
    title = "Top Reviewed Airbnb Hosts in the last 30 Days",
    subtitle = "Logan Square, Chicago") |>
  data_color(
    columns = Rating,
    colors = scales::col_numeric(
    palette = c("white", "red"),
    domain  = range(top_reviewed_hosts$Rating)
    )) |> 
  data_color(
    columns = `# Reviews`,
    colors = scales::col_numeric(
    palette = c("white", "red"),
    domain  = range(top_reviewed_hosts$`# Reviews`)
    )
  )
```

# Combine Datasets

When we explore the dataset, we are likely working a few variable combinations nad might have created some smaller dataset for convenience, then maybe we we want to bring different pieces together, for example, to look at the price of properties by the year they were listed.

If the smaller datasets you’re combining have the **same number of rows** and you haven't changed the row order or removed any entries (like with our `df_price` and `df_age`), simply combining them works.

```{r}
df <- bind_cols(df_price, df_age)
```

But a more robust and flexible way to keep an identifiable variable (such as `id` ) in both datasets, so that we can combine them by using `left_join()`. This function merges two datasets by a shared key column and keeps **all rows from the left dataset**, adding matching rows from the right. If there are entries in the left dataset with no match in the right, those values will be filled with `NA`, signaling no match was found.

```{r}
df <- left_join(df_price, df_age, by = "id")
```

# Lab Report

Building on what we’ve learned in our data wrangling and visualization, your task this week is to explore the Airbnb dataset in a city that interests you.

At the beginning of your Quarto document, you have listed **three questions** you’re curious about. Start by selecting one city from [Inside Airbnb](https://insideairbnb.com/get-the-data/). Using your questions as the guide, clean the data and create smaller, focused datasets in whatever way makes the most sense for your analysis. Then, create visualizations to help answer each of your three questions.

Choose visualization types that you feel are most effective for communicating your insights. You're welcome to use and refine `ggplot()` for your plots. However, to apply what we practiced today, your visualizations should include at least one interactive `plotly` graph and one table created by `gt`.

In your write-up, reflect on what your answers to these questions tell you about the Airbnb market in your chosen city. What patterns do you notice? What surprises you?

Please complete your Quarto document and upload your rendered HTML file to Canvas by the end of day, Tuesday, Sep 23.
